# Section 3. HTTP 기본
## 모든 것이 HTTP
> HyperText Transfer Protocol
- HTML, TEXT, IMAGE, 음성, 영상, 파일, JSON, XML(API) 등 거의 모든 형태의 데이터 전송 가능
- 심지어 서버 간에 데이터를 주고 받을 때도 대부분 HTTP 사용
<br>

### HTTP 역사
- HTTP/0.9 (1991년): GET 메소드만 지원, HTTP 헤더 X
- HTTP/1.0 (1996년): 메소드, 헤더 추가
- HTTP/1.1 (1997년): 가장 많이 사용, 가장 중요한 버전!
  - 대부분의 기능이 다 들어있고, HTTP/2나 HTTP/3은 성능개선이 이루어진 버전
  - RFC2068 (1997) → RFC2616 (1999) → RFC7230~7235 (2014)
- HTTP/2 (2015년): 성능 개선
- HTTP/3 진행중: TCP 대신 UDP 사용, 성능 개선
<br>

### 기반 프로토콜
- TCP 기반: HTTP/1.1, HTTP/2
- UDP 기반: HTTP/3
- 현재는 HTTP/1.1 주로 사용
<br>

### HTTP 특징
- 클라이언트 서버 구조로 동작
- 무상태(stateless) 프로토콜 지향, 비연결성
- HTTP 메세지를 통해 통신
- 단순함, 확장 가능
<br>
<br>
<br>

## 클라이언트 서버 구조
- Request Response 구조
  - 클라이언트가 request를 보내고 서버가 응답할 때까지 기다렸다가 응답을 받은 후 동작
- 클라이언트는 서버에 요청을 보내고, 응답을 대기
- 서버가 요청에 대한 결과를 만들어 응답
- 클라이언트와 서버를 분리해서 비즈니스 로직이나 데이터 같은 것들은 다 서버에 몰아넣고, 클라이언트는 UI, 사용성 등에 집중한다.
<br>
<br>
<br>

## Stateful, Stateless
### 무상태 프로토콜(Stateless)
- 서버가 클라이언트의 상태를 보존하지 않는다.
- 장점: 서버 확장성이 높다. 
- 단점: 클라이언트가 추가 

#### Stateful
```
고객: 이 노트북 얼마인가요?
점원: 100만원 입니다. (노트북 상태 유지)

고객: 2개 구매하겠습니다.
점원: 200만원입니다. 신용카드, 현금 중에 어떤 걸로 결제하시겠어요? (노트북, 2개 상태 유지)

고객: 신용카드로 구매하겠습니다.
점원: 200만원 결제완료되었습니다. (노트북, 2개, 신용카드 상태 유지)
```
<br>

#### Stateful, 점원이 중간에 바뀌는 경우
```
고객: 이 노트북 얼마인가요?
점원A: 100만원 입니다.

고객: 2개 구매하겠습니다.
점원B: 무엇을 2개 구매하시겠어요?

고객: 신용카드로 구매하겠습니다.
점원C: 무슨 제품을 몇 개 신용카드로 구매하시겠어요?
```
→ 점원이 필요한 데이터를 제공하지 않는다. <br>
→ 다른 점원으로 넘어가면 context가 사라진다.
<br>
<br>

#### Stateless, 점원이 중간에 바뀌는 경우
```
고객: 이 노트북 얼마인가요?
점원A: 100만원 입니다.

고객: 노트북 2개 구매하겠습니다.
점원B: 노트북 2개는 200만원입니다. 신용커드, 현금 중에 어떤 걸로 결제하시겠어요?

고객: 노트북 2개를 신용카드로 구매하겠습니다.
점원C: 200만원 결제 완료되었습니다.
```
→ 점원이 필요한 정보를 다 제공한다.
<br>
<br>

### Stateful vs Stateless
- Stateful(상태 유지)
  - 중간에 다른 점원으로 바뀌면 안된다. (다른 점원으로 바뀔 때 상태 정보를 다른 점원에게 미리 알려줘야 한다.)
- Stateless(무상태)
  - 중간에 다른 점원으로 바뀌어도 된다.
  - 갑자기 고객수가 증가해도 점원을 대거 투입할 수 있다.
  - 갑자기 클라이언트 요청이 증가해도 서버를 대거 투입할 수 있다.
- 무상태(Stateless)는 응답 서버를 쉽게 바꿀 수 있다. 
  - 서버가 상태를 보관하지 않고 클라이언트가 필요한 정보를 다 담아서 보내주기 때문에 서버 교체가 쉽다. <br>
→ 무한 서버 증설 가능
<br>

### Stateless의 한계
- 모든 것을 무상태로 설계할 수 있는 경우도 있고, 없는 경우도 있다.
- 무상태(Stateless)
  - ex) 로그인이 필요 없는 단순한 서비스 소개 화면
- 상태 유지(Stateful)
  - ex) 로그인
  - 로그인한 사용자의 경우, 로그인했다는 상태를 서버에 유지해야 한다.
  - 일반적으로 브라우저 쿠키와 서버 세션 등을 사용해 상태 유지
  - 상태 유지는 최소한만 사용해야 한다.
<br>
<br>
<br>

## 비연결성(connectionless)
- HTTP는 기본적으로 연결을 유지하지 않는 모델 (계속 연결을 유지하지 않는다.)
- 일반적으로 초 단위 이하의 빠른 속도로 응답
- 1시간 동안 수천명이 서비스를 사용해도 실제 서버에서 **동시에** 처리하는 요청은 수십개 이하로 매우 작다. <br>
→ 서버 자원을 매우 효율적으로 사용할 수 있다.

### 비연결성의 한계와 극복
- TCP/IP 연결을 계속 새로 맺어야 한다. (3 way handshake에 걸리는 시간 추가)
- 웹 브라우저로 사이트를 요청하면 HTML뿐만 아니라 자바스크리브, css, 추가 이미지 등 수많은 자원이 함께 다운로드된다. <br>
→ 현재는 HTTP 지속 연결(Persistent Connection)으로 문제 해결
